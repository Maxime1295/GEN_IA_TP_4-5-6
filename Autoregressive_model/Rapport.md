**PixelCNN**
1. Modèle autoregressif
PixelCNN fait partie des modèles autoregressifs car il génère les pixels un par un, en apprenant des images d'entraînement. Le but de ce modèle est de générer des images. Son principe de fonctionnement est d'observer dans une image les pixels précédents(à gauche du pixel ainsi que les pixels se trouvant du pixel au-dessus) puis de générer pixel par pixel une image. Le fait de se baser sur les pixels précédents pour apprendre une distribution à la manière de la formule de Bayes le rend autorégressifs.
2. Masques
Pour éviter que le modèle ne se base sur les pixels suivants, on utilise des masques. Ces masques sont des matrices qui permettent de ne prendre en compte que les pixels précédents. Il y a deux types de masques, les A et les B. Les A servent à prédire le pixel que l'on veut prédire, ils sont utilisés au début du modèle. Les B servent à montrer tous les pixels générés afin de prédire celui d'après. La différence est que le masque A cache un pixel de plus. On ne peut pas utiliser les mêmes masques sinon la prédiction ou bien la génération serait évidente pour le modèle. On applique le masque au kernel avant de faire le produit de convolution.
3. Implémentation
-On commence par charger un dataset d'images en lui appliquant la transformation pour que chaque pixel soit codé en un certain nombre de pixels levels.
-Nous créons ensuite une classe MaskedConv2d qui prend en argument mask_type. Il est très important que cette classe hérite de nn.Conv2D car il s'agit ni plus ni moins d'une Conv2D auquel on applique un masque avant de l'utiliser, la fonction super permettant de récupérer les propriétés de la classe parent et la multiplication par sel.mask applique le masque.
-Le bloc résiduel est composé d'une "vraie" mask convolution avec un kernel size 3 entouré de deux convolution qui ne font que des multiplications linéaires et de fonctions d'activation ReLU. Son forward passe est x + self.block(x) ce qui imbrique des termes puisqu'il y a plusieurs blocs residual de suite.
-Le modèle est donc une séquence de couches analysant les images, 5 blocs residuels dans notre cas pour aprendre à générer, de couches de mask convolution avec kernel size de 1 et une couche de convolution pour obtenir une sortie de pixel levels correspondant au nombre de couleurs.
-On entraîne le modèle sur un dataset d'images et on génère des images à partir de ce modèle.
## Génération
1. Génération
On finit par générer une image en itérant sur le nombre de pixels dans chaque ligne et en itérant pour chaque colonne. Le modèle reçoit une matrice de zeros qu'il modifie pixel par pixel en utilisant softmax. La fonction softmax appliquer à un vecteur rend la somme des termes du vecteur ainsi obtenu égale à un, ce qui permet de définir la probabilité estimé. La valeur du pixel est tiré au sort en fonction de ce vecteur de probabilité en utilisant la loi multinomiale. La température contrôle la diversité de la génération.